자바에서 System.out.println 말고도 System.out.printf 도 사용 가능하다.
예) System.out.printf("%d %d\n", i, j);

print문은 System.out인데, 반대로 입력하는 scan문은 System.out이 아닌, System.in 이다.
import java.util.Scanner;
Scanner in = new Scanner(System.in);
int num_name = in.nextInt();

Scanner[클래스 이름] in[객체 이름] = new Scanner[클래스 이름](System.in);
int num_name = in.nextInt();
객체 이름은 내가 편한대로 지정하면 된다.
(대체로 Scanner 의 경우 객체이름은 in, input, sc, scan 이렇게 4가지가 가장 많이 쓰인다.)

예를들어
Scanner shj = new Scanner(System.in);  // 선언함
int num_name = shj.nextInt();  // 이 줄에서 입력 실행
같은말은
Scanner shj = new Scanner(System.in);
int num;
num = shj.nextInt();
위를 전문적으로 설명해보면,
Scanner라는 불러온 클래스로 shj라는 새로운 객체를 만들어주었고,
num라는 변수에 shj객체를 nextInt() 메소드로 실행한 값을 저장해준것이다.
즉, 이제 숫자를 입력하면된다.
이게 이해가 안된다면, 저 밑쪽에 적어둔 클래스 관련 설명을 읽고 다시 올것.

random 숫자도 scanner와 비슷하다.
Random rand = new Random();  //  Random rand = new Random(최댓값)+최솟값; 이렇게 적어주면 범위 설정 가능함.
int ran_num = rand.nextInt();
전문적으로 좀더 이해하기 쉬운방법으로 설명해보자면,
Random rand = new Random(); 여기서 =의 뒷부분부터 읽어주고 그 후에 앞부분을 읽어주자.
Random 클래스(함수 담긴 구조체)로 새로운 무언가를 만들어줄것이다 -> 그것은 바로 Random 클래스로 rand 라는 이름의 새로운 객체이다.
그 다음은 int ran_num = rand.nextInt(); 이걸 해석해보자면,
rand 객체의 nextInt() 메소드를 실행하여, ran_num라는 이름으로 선언된 변수에 그 결과값을 넣어주겠다는 뜻이다.
이 모든 과정을 요약하면, 클래스로 새로운 객체를 생성하고, 그 객체 안의 메소드(함수)를 이용하여, 선언한 변수에 그 값을 넣어주는 것이다(변수 생성).
이게 이해가 안된다면, 저 밑쪽에 적어둔 클래스 관련 설명을 읽고 다시 올것.

<스캐너 관련 메소드명 인터넷에서 가져온것>
nextBoolean()	boolean의 자료형을 입력받습니다. 자료형은 두개인 true,false로 대소문자를 구분하지 않습니다.  
nextByte()	byte의 자료형을 입력으로 받습니다. 입력 범위(127~ -128) 밖이면 InputMismatchException이 발생합니다.
nextShort()	short의 자료형을 입력받습니다.
nextInt()	int형의 자료형을 입력받습니다. 
nextLong()	long형의 자료형을 입력받습니다.
nextDouble()	double형의 자료형을 입력받습니다.
nextFloat()	float형의 자료형을 입력받습니다.
next()		String형의 문자열을 입력받습니다. 이때 공백 문자까지 입력받습니다.  
nextLine()	문자열을 입력받는데 다른 next~() 메소드와 다른 점은 줄단위로 입력받는다는 점입니다. 

---------------------------------------------------------------------------------
scan의 예)

import java.util.Scanner;  // 이렇게 클래스 선언전에 첫번째로 스캐너 임포트 해주고
public class Hello2 {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);  // 보통 이렇게 위에다가 먼저 스캐너 선언해주고 (여기서는 in 이란 객체 이름으로 스캐너 만듬.)
		System.out.print("점수를 입력하세요: ");
		int jumsu = in.nextInt();  // 요렇게 사용 (위에서 만든 스캐너의 객체이름인 in을 그대로 사용함.)
		String grade;  // 문자열 선언할때만 string이 아닌 String 이다. 다른 자료형들은 소문자 int 등등 그대로 해주면된다.

		if (jumsu >= 90)
			grade = "A";
		else if (jumsu >= 80)
			grade = "B";
		else if (jumsu >= 70)
			grade = "C";
		else if (jumsu >= 60)
			grade = "D";
		else
			grade = "F";

		System.out.println("학점 출력: " + grade);
	}
}

---------------------------------------------------------------------------------
scan의 예2)

import java.util.Scanner;

public class Hello2 {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int num = 1;

		while (num != 0) {
			System.out.print("숫자를 입력하시오: ");
			num = in.nextInt();
		}
		System.out.println("프로그램을 종료합니다.");
	}
}
---------------------------------------------------------------------------------
random의 예)

import java.util.Random;
import java.util.Scanner;

public class Hello2 {
	public static void main(String args[]) {
		Random rand = new Random();
		int ran_num = rand.nextInt(20) + 1;  // 1~20 까지의 랜덤숫자 지정함.

		Scanner in = new Scanner(System.in);
		System.out.println("숫자를 입력해서 맞춰보세요: ");
		int scan_num = in.nextInt();

		if (ran_num == scan_num)
			System.out.println("숫자를 맞히셨습니다!");
		else {
			while (ran_num != scan_num) {
				if (ran_num < scan_num) {
					System.out.println("틀렸습니다. 정답숫자는 이보다 더 작습니다!");
					scan_num = in.nextInt();
				} else {
					System.out.println("틀렸습니다. 정답숫자는 이보다 더 큽니다!");
					scan_num = in.nextInt();
				}
			}
			System.out.println("숫자를 맞히셨습니다!");
		}
	}
}

---------------------------------------------------------------------------------
클래스로부터 객체 생성하는것도 scanner와 random과 비슷하다.
예를들어, Student 클래스로부터 shj 객체를 생성한다면,
Student shj = new Student();
이로써 shj라는 학생의 객체(사람)이 만들어진것이다.
이게 이해가 안된다면, 저 밑쪽에 적어둔 클래스 관련 설명을 읽고 다시 올것.
참고로 Student shj = new Student("201921003", "001106"); 이런식으로 입력하는 방법이 있긴한데, 개인적으로 이상해서 비추천한다.
예시는 둘다 밑에 적어놨다.

========================================
========================================
<보통의 방법으로, 클래스로 새로운 객체 만들때>
<default package 안의 Hello.java 파일>

import sub.Student;

public class Hello {
	public static void main(String args[]) {
		Student shj = new Student();
		shj.hakbun = "201921003";
		shj.birth = "001106";

		System.out.println(shj.hakbun);
		System.out.println(shj.birth);
		shj.gongbu();
	}
}

/*
<출력결과>
201921003
001106
201921003 학번이고 001106 생년월일인 학생은 공부를 열심히 합니다!
 */

---------------------------------------------
<보통의 방법으로, 클래스로 새로운 객체 만들때>
<sub package 안의 Student.java 파일>

package sub;

public class Student {

	public String hakbun;
	public String birth;

	public void gongbu() {
		System.out.printf("%s 학번이고 %s 생년월일인 학생은 공부를 열심히 합니다!", hakbun, birth);
	}
}

========================================
<굳이 클래스 매개변수에 구조체처럼 무언가를 넣을때(매개변수가 있는 생성자 사용)>
<default package 안의 Hello.java 파일>

import sub.Student;

public class Hello {
	public static void main(String args[]) {
		Student shj = new Student("201921003", "001106");

		System.out.println(shj);
		System.out.println(shj.hakbun);
		System.out.println(shj.birth);
		System.out.println();

		shj.hakbun = "2019";
		shj.birth = "1106";
		System.out.println(shj.hakbun);
		System.out.println(shj.birth);
		System.out.println();

		System.out.println(shj);
	}
}

/*
<출력결과>
201921003 학번이고 001106 생년월일인 학생은 공부를 열심히 합니다!sub.Student@77459877
null
null

2019
1106

sub.Student@77459877

*/

---------------------------------------------
<굳이 클래스 매개변수에 구조체처럼 무언가를 넣을때(매개변수가 있는 생성자 사용)>
<sub package 안의 Student.java 파일>

package sub;

public class Student {

	public String hakbun;
	public String birth;

	public Student(String hakbun, String birth) {
		System.out.printf("%s 학번이고 %s 생년월일인 학생은 공부를 열심히 합니다!", hakbun, birth);
	}
}
========================================
========================================

<지역변수 관련 자바 코드>

public class Hello2 { 
	public static void main(String[] args) {
		int x = 0;
		System.out.println("전 x: " + x);
		func(x);
		System.out.println("후 x: " + x);

	}
	public static void func(int n) {
		System.out.println("메서드 시작 n: " + n);
		n++;
		System.out.println("메서드 끝 n: " + n);
	}
}

출력 => 
전 x: 0
메서드 시작 n: 0
메서드 끝 n: 1
후 x: 0

메서드는 c언어에서 함수와 동일하다고 보면 될 것 같다.
그리고 c언어처럼 메서드(함수)에서 리턴값없이 변수를 다시 메인 메서드(함수)로 가져오면 지역변수로써 숫자가 날아간다.
---------------------------------------------------------------------------------
그리고 바로 위의 예시 코드에서 확인할수 있는점은,
c언어는 외부 함수를 메인함수에서 쓰기위해서는 메인함수보다 먼저 선언해주거나 해야하는데,
반면에 자바는 다른 외부 메서드(함수)를 메인 메서드(함수)에서 사용할때, 메인 메서드보다 외부 메서드를 나중에 선언해서 작성하여도 코드가 잘 작동한다.
참고로 반대의 경우를 직접 코드로 확인해봤는데, 아마 c언어처럼 외부 메서드 먼저 선언하고 메인 메서드를 나중에 선언하여 사용하여도 문제없이 잘 작동하는듯하다.

break문은 안쪽 반복문을 종료하고 빠져나오게 된다.
보통 while(true) 같은 무한반복문에 자주 쓰인다.
참고로 break out 으로 안쪽반복문뿐만 아니라 바깥쪽반복문까지 탈출시킬수 있다.

continue문은 예를들어 while문에서 break와 다르게 탈출시키지않고,
continue 밑의 문장을 실행시키지 않고 다시 반복문으로 돌아가 반복을 마저 이어서 실행시킬수 있게 한다.

------------------------------------------------------------------------
<인터넷에서 가져온 메인 메소드 public과 static 관련 정보>

static은 정적이란 뜻이다. 메서드에 붙이게 되면 이 메서드는 정적 메서드임을 나타낸다.
static으로 선언하게 되는 경우 자바가 컴파일 되는 시점에 정의가 된다. 그리고 static 요소를 static이 아닌 요소에서 호출하는 것은 불가능하다.
특히나 main 메서드처럼 프로그램의 시작점이 되는 요소는 객체를 생성하지 않아도 작업을 수행해야 하기 떄문에 static이어야 한다.

그리고 C언어와 마찬가지로 자바 언어에서도 main 메서드가 먼저 실행된다. 그런데 실행되기 위해서는 메모리에 미리 올라가야 한다.
그렇기 때문에 static을 선언하여 메모리 할당(new)를 하지 않아도 사용할 수 있게 만든다.
특히나 main 메서드는 자바 가상 머신(JVM: Java Virtual Machine)에 의해 호출되기 때문에 반드시 static으로 선언되어 미리 로드되어 있어야 한다.

위의 정보 출처 사이트: https://madplay.github.io/post/java-main-method-structure

------------------------------------------------------------------------
<인터넷에서 가져온 자바 클래스 정의>

클래스란 유사한 특징을 지닌 객체들의 속성을 묶어 놓은 집합체입니다.
예를들어 설명하자면 학교에는 "김동수"나 "이영희"나 "안준영" 등등 많은 아이들이 있습니다. 
이러한 아이들의 특성을 하나로 묶는 단 하나의 명칭이 있죠. 바로 "학생"이라는 단어 입니다.
여기서 "학생"이라는 의미가 클래스이고, 하나하나의 "학생"이 객체라는 것이죠.
즉 "김동수"란 아이는 "학생"이라는 개념에서 정의된 하나의 객체란 의미이죠. 
다시 프로그래밍 개념으로 와서 생각하자면 하나의 클래스를 정의하고, 그 클래스로부터 하나의 실례를 만드는것을 "객체 또는 인스턴스를 생성한다." 라고 말합니다.

c언어의 구조체(변수만 들어갈수있고, 함수는 넣을수 없음)에다가 함수도 넣을 수 있게 기능을 추가한 버전이
자바의 클래스라고 생각하면 된다. 그래서 클래스 안에는 속성(변수)과 행위(함수 = 메소드)가 들어있다.
이 클래스에 만약에, 학생에 대한 '학번,  이름, 생년월일' 같은 정보와 그 학생의 행동 '수강하다, 시험보다, 성적받다'에 대한 정보 집합체가 들어있다고 치자.
그러면 이렇게 c언어의 구조체와 흡사하게 보이는 이러한 자바의 클래스로 그 안에 해당 값에대한 정보를 기입하여 어떠한 특정한 학생 '사현진'에 대한 객체 정보를 만들어낼수 있다.

더 쉽게 말하면 '함수를 넣을수있는 구조체'라는 클래스 안에 정보를 기입하여 객체 하나를 만들어서 그거 객체 자체로 사용하는 것이다.

------------------------------------------------------------------------
<인터넷에서 가져온 클래스와 객체와 인스턴스 설명>

클래스(Class) 란:
- 개념
객체를 만들어 내기 위한 설계도 혹은 틀
연관되어 있는 변수와 메서드의 집합

객체(Object) 란:
- 개념
소프트웨어 세계에 구현할 대상
클래스에 선언된 모양 그대로 생성된 실체
- 특징
'클래스의 인스턴스(instance)' 라고도 부른다.
객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
oop의 관점에서 클래스의 타입으로 선언되었을 때 ‘객체’라고 부른다.

인스턴스(Instance) 란:
-개념
설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
즉, 객체를 소프트웨어에 실체화 하면 그것을 ‘인스턴스’라고 부른다.
실체화된 인스턴스는 메모리에 할당된다.
-특징
인스턴스는 객체에 포함된다고 볼 수 있다.
oop의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 ‘인스턴스’라고 부른다.
추상적인 개념(또는 명세)과 구체적인 객체 사이의 관계 에 초점을 맞출 경우에 사용한다.
‘~의 인스턴스’ 의 형태로 사용된다.
객체는 클래스의 인스턴스다.
객체 간의 링크는 클래스 간의 연관 관계의 인스턴스다.
실행 프로세스는 프로그램의 인스턴스다.
즉, 인스턴스라는 용어는 반드시 클래스와 객체 사이의 관계로 한정지어서 사용할 필요는 없다.
인스턴스는 어떤 원본(추상적인 개념)으로부터 ‘생성된 복제본’을 의미한다.

------------------------------------------------------------------------
<인터넷에서 가져온 캡슐화와 정보은닉 설명 정리>

[캡슐화]
캡슐화는 데이터와 기능(알고리즘)을 하나로 묶은 것으로,
캡슐화는 관련이 있는 변수와 함수를 하나의 클래스로 묶고 외부에서 쉽게 접근하지 못하도록 은닉하는게 핵심입니다.
객체에 직접적인 접근을 막고 외부에서 내부의 정보에 직접 접근하거나 변경할 수 없고, 객체가 제공하는 필드와 메소드를 통해서만 접근이 가능합니다.
그러므로 캡슐화의 가장큰 장점은 정보은닉(Information Hiding)에 있습니다.
이로써 객체는 캡슐화와 정보은닉의 도구이다.
[정보은닉]
외부에서 객체접근하는데 있어서 정보를 숨기고 객체의 연산을 통해서만 접근이 가능하게 하는 것입니다.
정보은닉의 장점은 외부에서 특정 객체의 데이터 및 함수를 직접 접근을 막음으로써 변경을 못하게 하고 유지보수나 확장시 오류의 범위를 최소화 할 수 있고,
객체내 정보손상, 오용을 방지하고, 조작법이 바뀌어도 사용방법 자체는 바뀌지 않고, 데이터가 변경되어도 다른 객체에 영향을 주지 않기 때문에 독립성이 좋고,
처리된 결과사용으로 이식성이 좋고, 객체를 모듈화 할 수있어 새로운 시스템의 구성에 하나의 모듈처럼 사용이 가능하다.
[캡슐화와 정보은닉의 장점]
- 유지보수 용이: 객체에 대한 수정 작업으로 인해 객체 활용도에 문제가 발생한다면 제품 하나에 대한 upgrade가 상당히 부담스러울 것입니다.
자바에서는 각 기능을 하나의 모듈(부품)처럼 활용하여 객체간의 이식성이 높고 독립적인 면을 유지하는 장점이 있습니다.
- 모듈화 향상: 위의 유지보수 용이에 적힌 장점대로 각 기능을 하나의 모듈(부품)처럼 활용하여 객체간의 이식성이 높고 독립적인 면을 유지할 수 있다.
- 추상화 향상: 추상화는 사용자에게 불필요한 세부정보는 숨기고 중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것인데,
현실 세계에 존재하는 다양한 객체들의 공통된 특성과 구체적인 사실들을 모아 일반화 해놓은것이다.
예를들어 사용자는 전기 압력밥솥이 어떤 원리와 어떤 과정으로 밥을 지어내는지는 알 필요 없이 그냥 사용법만 익혀서 밥을 짓는데에 전기밥솥을 사용한다.
- 재사용성 향상: 상속(Inheritance)은 속성과 메서드가 약간 다른 객체를 필요로 할 때, 기존의 클래스를 이용하여 새로운 클래스를 작성하는 것인데,
즉, 이미 존재하는 클래스를 바탕으로 필요한 변수와 메서드를 추가로 정의해준 것이 상속이다.
클래스들 사이에 공통된 속성이나 기능들이 있을 경우, 상속을 통해 재사용성을 높일 수 있음.
이는 코드를 간결하게 하여 코드의 재사용성을 높이는 객체지향의 핵심 개념이자 장점이다.
- 데이터 보호(이건 추가적으로 적어봄): 은닉화를 통해 데이터의 접근을 제어할 수 있습니다.

------------------------------------------------------------------------
<인터넷에서 가져온 자바 접근 제한자의 종류와 차이>

자바 접근 제한자의 종류와 차이(public, protected, private)):
https://hongong.hanbit.co.kr/%EC%9E%90%EB%B0%94-%EC%A0%91%EA%B7%BC-%EC%A0%9C%ED%95%9C%EC%9E%90%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EC%B0%A8%EC%9D%B4public-protected-private/

------------------------------------------------------------------------
<인터넷에서 가져온 상속 클래스 설명과 사용방법>

상속 클래스 설명과 사용방법: https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=heartflow89&logNo=220960019390

참고로 부모 클래스가 자식 클래스를 쓸 수는 없다. 자식 클래스가 부모 클래스를 끌어다가 쓰는것이다.

그리고 자바에서는 자식 클래스가 여러 부모로부터 다중 상속을 받는 것은 불가능하다.
즉, 1개의 부모 클래스로부터의 단일 상속만 허용된다.  하지만 부모 클래스는 여러 개의 자식 클래스에게 상속이 가능하다.
쉽게 설명하면, 하나의 자식 클래스가 부모 클래스를 끌어올때는 둘 이상의 여러 부모 클래스를 끌어올수가 없지만, 반대로 하나의 부모 클래스는 여러 종류의 자식 클래스에게 상속시킬수 있다는 것이다.
class 자식클래스1 extends 부모클래스1,부모클래스2 {} 은 불가능 => 다중 상속 불가능
class 자식클래스1 extends 부모클래스1{} 와 class 자식클래스2 extends 부모클래스1{} 은 동시에 가능 => 단일 상속 가능
외우기쉽게 1부모클래스는 2자식클래스 이상 상속 가능하다 이렇게 외워두자.

------------------------------------------------------------------------
<인터넷에서 가져온 인터페이스 설명과 현실적인 예시>

- 인터페이스(interface)란?
자식 클래스가 여러 부모 클래스를 상속받을 수 있다면, 다양한 동작을 수행할 수 있다는 장점을 가지게 될 것입니다.
하지만 클래스를 이용하여 다중 상속을 할 경우 메소드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어 자바에서는 클래스를 통한 다중 상속은 지원하지 않습니다.
하지만 다중 상속의 이점을 버릴 수는 없기에 자바에서는 인터페이스라는 것을 통해 다중 상속을 지원하고 있습니다.
인터페이스(interface)란 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스를 의미합니다.
자바에서 추상 클래스는 추상 메소드뿐만 아니라 생성자, 필드, 일반 메소드도 포함할 수 있습니다.
하지만 인터페이스(interface)는 오로지 추상 메소드와 상수만을 포함할 수 있습니다.

- 쉬운 현실적인 예시
교수님이 학생들에게 논문을 쓰라고 했다.
A학생은 PPT로 논문을 11일날 제출했다.
B학생은 EXCEL 2016 로 논문을 12일날 제출했다.
C학생은 EXCEL 2019 로 자기만의 색깔을 입혀 표 형식으로 12일날 제출했다.
D학생은 메모장에 '논문'을 쓰고 교수님이 말해준 당일 바로 제출했다.
응?? 논문을 쓰라고 지시했지만, 결과물이 너무 개성이 넘친다....이건 평가할 수 없을 것 같다. 왜 이런일이 일어날까?
가이드 라인 또는 어떠한 규격이 없기 때문에 발생하는 문제이다.
따라서 교수는 다시 명확한 가이드라인 있는 논문을 쓰라고 지시해야한다. 아래처럼...
학생들에게 2019.12.12일 18:00까지 홈페이지 본인 교수 홈페이지 제출란을 통해 논문을 제출해야하고
논문 파일 형식은 .PPT이며 10Page 안에 작성을 해야하고 논문 주제는 '블록체인을 활용한 공인인증서' 이다.

이와같은 가이드라인이 인터페이스이다.

- 인터페이스(interface)의 내부 규칙
인터페이스는 호출 규칙을 정의하는 것이기 때문에 추상 메서드만 선언 가능하다.
인터페이스는 인스턴스 변수를 가질 수 없다.
즉 인터페이스에 선언된 모든 메서드는 public이고 abstract이다.
public만 사용 가능하다는점이 중요하다.
-> 공개(public) 인터페이스
------------------------------------------------------------------------

